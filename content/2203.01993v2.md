---
title: 2203.01993v2 Polarity Sampling  Quality and Diversity Control of Pre-Trained Generative Networks via Singular Values
date: 2022-03-02
---

# [Polarity Sampling: Quality and Diversity Control of Pre-Trained Generative Networks via Singular Values](http://arxiv.org/abs/2203.01993v2)

authors: Ahmed Imtiaz Humayun, Randall Balestriero, Richard Baraniuk


## What, Why and How

[1]: https://arxiv.org/abs/2203.01993 "[2203.01993] Polarity Sampling: Quality and Diversity Control of Pre ..."
[2]: https://arxiv.org/pdf/2003.01993v2.pdf "arXiv:2003.01993v2 [cs.LG] 15 Mar 2020"
[3]: https://arxiv.org/pdf/2203.01993v1.pdf "arXiv.org"
[4]: http://export.arxiv.org/abs/2302.01993v2 "Title: ALLIANCE: Spectral solver for kinetic plasma turbulence"

Here is a summary of the paper[^1^][1]:

- **What**: The paper presents a method called **Polarity Sampling** for controlling the quality and diversity of images generated by pre-trained deep generative networks (DGNs).
- **Why**: The paper aims to address the challenge of balancing the trade-off between quality and diversity of DGNs, which are often trained on large and diverse datasets but may suffer from mode collapse or low fidelity issues.
- **How**: The paper leverages the fact that DGNs are, or can be approximated by, continuous piecewise affine splines, and derives the analytical DGN output space distribution as a function of the product of the DGN's Jacobian singular values raised to a power . The paper introduces a parameter called **polarity** that focuses the DGN sampling on the modes () or anti-modes () of the output-space distribution. The paper shows that polarity sampling can achieve a better precision-recall (quality-diversity) Pareto frontier than standard methods, such as truncation, for various state-of-the-art DGNs on different image generation tasks.

## Main Contributions

According to the paper, the main contributions are:

- A novel plug-and-play method for controlling the quality and diversity of pre-trained DGNs via polarity sampling, which is theoretically justified and easy to implement.
- A proof that polarity sampling can achieve a better precision-recall Pareto frontier than truncation for any DGN that is, or can be approximated by, a continuous piecewise affine spline.
- A demonstration that polarity sampling can improve the overall generation quality (e.g., in terms of the Frechet Inception Distance) for various state-of-the-art DGNs, such as StyleGAN3, BigGAN-deep, NVAE, on different conditional and unconditional image generation tasks. In particular, polarity sampling redefines the state-of-the-art for StyleGAN2 on the FFHQ Dataset to FID 2.57, StyleGAN2 on the LSUN Car Dataset to FID 2.27 and StyleGAN3 on the AFHQv2 Dataset to FID 3.95.

## Method Summary

[1]: https://arxiv.org/abs/2203.01993 "[2203.01993] Polarity Sampling: Quality and Diversity Control of Pre ..."
[2]: https://arxiv.org/pdf/2003.01993v2.pdf "arXiv:2003.01993v2 [cs.LG] 15 Mar 2020"
[3]: http://export.arxiv.org/abs/2302.01993v2 "Title: ALLIANCE: Spectral solver for kinetic plasma turbulence"

Here is a summary of the method section of the paper[^1^][1]:

- The paper first introduces the concept of **polarity** as a parameter that controls the sampling of DGNs by modifying the latent space distribution. The paper defines polarity as the product of the DGN's Jacobian singular values raised to a power , where is a user-defined parameter that can be positive or negative.
- The paper then derives the analytical expression for the DGN output space distribution as a function of polarity, assuming that the DGN is, or can be approximated by, a continuous piecewise affine spline. The paper shows that polarity sampling can focus the DGN sampling on the modes () or anti-modes () of the output-space distribution, depending on the sign and magnitude of .
- The paper then proposes a plug-and-play algorithm for implementing polarity sampling for any pre-trained DGN, which only requires access to the latent space and the Jacobian matrix of the DGN. The algorithm consists of three steps: (1) sampling a latent vector from a standard normal distribution, (2) applying polarity sampling by multiplying the latent vector by a random sign and a scaling factor that depends on , and (3) passing the modified latent vector to the DGN to generate an image.
- The paper then evaluates the performance of polarity sampling on various state-of-the-art DGNs, such as StyleGAN3, BigGAN-deep, NVAE, on different conditional and unconditional image generation tasks. The paper uses several metrics to measure the quality and diversity of the generated images, such as precision-recall curves, Frechet Inception Distance (FID), Inception Score (IS), and Kernel Inception Distance (KID). The paper also compares polarity sampling with other methods for controlling DGNs, such as truncation and temperature scaling.

## Pseudo Code - High level

Here is the high-level pseudo code for polarity sampling:

```python
# Input: a pre-trained DGN f, a polarity parameter alpha
# Output: a generated image x

# Step 1: sample a latent vector z from a standard normal distribution
z = np.random.randn(D) # D is the dimension of the latent space

# Step 2: apply polarity sampling by multiplying z by a random sign and a scaling factor
sign = np.random.choice([-1, 1]) # randomly choose -1 or 1
J = f.jacobian(z) # compute the Jacobian matrix of f at z
s = np.linalg.svd(J, compute_uv=False) # compute the singular values of J
p = np.prod(s**alpha) # compute the polarity as the product of singular values raised to alpha
z = sign * p * z # modify the latent vector by polarity sampling

# Step 3: pass the modified latent vector to the DGN to generate an image
x = f(z) # generate an image from the modified latent vector
return x # return the generated image
```

## Pseudo Code - Detail

Here is the detailed pseudo code to implement polarity sampling:

```python
# Input: a pre-trained DGN f, a polarity parameter alpha, a batch size N
# Output: a batch of generated images X

# Initialize an empty list to store the generated images
X = []

# Repeat N times
for i in range(N):
  # Step 1: sample a latent vector z from a standard normal distribution
  z = np.random.randn(D) # D is the dimension of the latent space

  # Step 2: apply polarity sampling by multiplying z by a random sign and a scaling factor
  sign = np.random.choice([-1, 1]) # randomly choose -1 or 1
  J = f.jacobian(z) # compute the Jacobian matrix of f at z
  s = np.linalg.svd(J, compute_uv=False) # compute the singular values of J
  p = np.prod(s**alpha) # compute the polarity as the product of singular values raised to alpha
  z = sign * p * z # modify the latent vector by polarity sampling

  # Step 3: pass the modified latent vector to the DGN to generate an image
  x = f(z) # generate an image from the modified latent vector
  
  # Append the generated image to the list
  X.append(x)

# Convert the list of images to a numpy array
X = np.array(X)

# Return the batch of generated images
return X
```