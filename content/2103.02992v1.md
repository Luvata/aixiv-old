---
title: 2103.02992v1 Clusterplot  High-dimensional Cluster Visualization
date: 2021-03-03
---

# [Clusterplot: High-dimensional Cluster Visualization](http://arxiv.org/abs/2103.02992v1)

authors: Or Malkai, Min Lu, Daniel Cohen-Or


## What, Why and How

[1]: https://arxiv.org/abs/2103.02992 "[2103.02992] Clusterplot: High-dimensional Cluster Visualization"
[2]: https://arxiv.org/pdf/2103.02992.pdf "arXiv:2103.02992v1 [cs.GR] 4 Mar 2021"
[3]: http://export.arxiv.org/abs/2103.02992 "[2103.02992] Clusterplot: High-dimensional Cluster Visualization"

Here is a summary of the paper:

- **What**: The paper presents **Clusterplot**, a multi-class high-dimensional data visualization tool designed to visualize cluster-level information offering an intuitive understanding of the cluster inter-relations[^1^][1] [^2^][2].
- **Why**: The paper aims to address the challenges of exploring multi-class high-dimensional data with a known classification, such as data generated by deep learning models. Existing techniques such as PCA, t-SNE, and UMAP often cause visual clutter, compromise cluster structure, or ignore class identity supervision[^2^][2].
- **How**: The paper proposes a novel technique that leverages 2D blobs devised to convey the geometrical and topological characteristics of clusters within the high-dimensional data, and their pairwise relations, such that general inter-cluster behavior is easily interpretable in the plot. Class identity supervision is utilized to drive the measuring of relations among clusters in high-dimension, particularly, proximity and overlap, which are then reflected spatially through the 2D blobs[^1^][1] [^2^][2]. The paper demonstrates the strength of Clusterplot and its ability to deliver a clear and intuitive informative exploration experience for high-dimensional clusters characterized by complex structure and significant overlap[^2^][2].


## Main Contributions

[1]: https://arxiv.org/abs/2103.02992 "[2103.02992] Clusterplot: High-dimensional Cluster Visualization"
[2]: https://towardsdatascience.com/best-practices-for-visualizing-your-cluster-results-20a3baac7426 "Best Practices for Visualizing Your Cluster Results"
[3]: https://indico.mpp.mpg.de/event/5932/contributions/14642/attachments/10689/11981/Talk_meggendorfer_imprs.pdf "4. Back to Physics 5. Conclusion 3. Test of Clusterplot with Generic ..."
[4]: https://www.rdocumentation.org/packages/LSD/versions/4.1-0/topics/clusterplot "clusterplot function - RDocumentation"

According to the paper[^1^][1] [^2^][2], the main contributions are:

- A novel technique for visualizing multi-class high-dimensional data that preserves cluster-level information and reflects inter-cluster relations in a 2D plot.
- A unique representation of clusters using 2D blobs that convey the geometrical and topological characteristics of clusters and their pairwise proximity and overlap.
- A class identity supervision scheme that drives the measuring of cluster relations in high-dimension and guides the spatial arrangement of the 2D blobs.
- A comprehensive evaluation of Clusterplot on various datasets and tasks, demonstrating its advantages over existing techniques.

## Method Summary

[1]: https://seaborn.pydata.org/generated/seaborn.clustermap.html "seaborn.clustermap â€” seaborn 0.12.2 documentation"
[2]: https://towardsdatascience.com/the-complete-guide-to-clustering-analysis-10fe13712787 "The complete guide to clustering analysis | by Antoine Soetewey ..."
[3]: https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/hclust "hclust function - RDocumentation"
[4]: https://www.rdocumentation.org/packages/LSD/versions/4.1-0/topics/clusterplot "clusterplot function - RDocumentation"

Here is a summary of the method section of the paper:

- The method section describes the main steps of Clusterplot: data preprocessing, cluster relation measuring, 2D blob generation, and 2D blob arrangement[^1^][2].
- Data preprocessing involves applying dimensionality reduction techniques such as PCA or UMAP to the high-dimensional data and normalizing the reduced data to the range [0,1][^1^][2].
- Cluster relation measuring involves computing two metrics for each pair of clusters: proximity and overlap. Proximity is defined as the average distance between the centroids of two clusters in high-dimension. Overlap is defined as the ratio of points that are closer to another cluster's centroid than their own cluster's centroid[^1^][2].
- 2D blob generation involves creating a 2D shape for each cluster that reflects its size, shape, and orientation in high-dimension. The shape is constructed by fitting an ellipse to the reduced data points of each cluster and scaling it by a factor that depends on the cluster size[^1^][2].
- 2D blob arrangement involves placing the 2D blobs on a 2D canvas such that they respect the proximity and overlap metrics computed in high-dimension. The placement is done by minimizing an energy function that penalizes deviations from the desired proximity and overlap values[^1^][2].

## Pseudo Code - High level

Here is a possible high-level pseudo code for this paper:

```
# Input: high-dimensional data X with n points and k clusters
# Output: a 2D plot of clusters with 2D blobs

# Data preprocessing
Apply dimensionality reduction technique (e.g. PCA or UMAP) to X and obtain Y with m dimensions (m << n)
Normalize Y to the range [0,1]

# Cluster relation measuring
For each pair of clusters i and j in Y:
  Compute proximity P_ij as the average distance between the centroids of i and j
  Compute overlap O_ij as the ratio of points that are closer to another cluster's centroid than their own cluster's centroid

# 2D blob generation
For each cluster i in Y:
  Fit an ellipse E_i to the points of i using eigenvalue decomposition
  Scale E_i by a factor S_i that depends on the size of i

# 2D blob arrangement
Initialize a 2D canvas C with width W and height H
Randomly place the 2D blobs on C
Define an energy function E that penalizes deviations from the desired proximity and overlap values
Repeat until convergence or maximum iterations:
  For each pair of blobs B_i and B_j on C:
    Compute the current proximity Q_ij as the distance between the centers of B_i and B_j
    Compute the current overlap R_ij as the area of intersection between B_i and B_j
    Compute the energy contribution E_ij as a weighted sum of squared errors between P_ij and Q_ij, and O_ij and R_ij
    Update E by adding E_ij
  For each blob B_i on C:
    Compute the gradient G_i of E with respect to the position of B_i
    Update the position of B_i by moving it along the opposite direction of G_i with a learning rate alpha

# Plotting
Plot C with the 2D blobs and their corresponding labels
```

## Pseudo Code - Detail

Here is a possible detailed pseudo code to implement this paper:

```
# Input: high-dimensional data X with n points and k clusters
# Output: a 2D plot of clusters with 2D blobs

# Data preprocessing
# Apply UMAP to X and obtain Y with 2 dimensions
Y = UMAP(X)

# Normalize Y to the range [0,1]
Y = (Y - min(Y)) / (max(Y) - min(Y))

# Cluster relation measuring
# Initialize proximity matrix P and overlap matrix O with zeros
P = zeros(k, k)
O = zeros(k, k)

# For each pair of clusters i and j in Y:
for i in 1..k:
  for j in i+1..k:
    # Compute proximity P_ij as the average distance between the centroids of i and j
    C_i = mean(Y[i]) # centroid of cluster i
    C_j = mean(Y[j]) # centroid of cluster j
    P_ij = distance(C_i, C_j) # Euclidean distance between centroids
    P[i,j] = P_ij
    P[j,i] = P_ij # symmetry
    
    # Compute overlap O_ij as the ratio of points that are closer to another cluster's centroid than their own cluster's centroid
    N_ij = 0 # number of points that belong to i or j and are closer to another cluster's centroid
    for p in Y[i] or Y[j]: # for each point p that belongs to cluster i or j
      if distance(p, C_i) > distance(p, C_j): # if p is closer to C_j than C_i
        N_ij = N_ij + 1
    O_ij = N_ij / (size(Y[i]) + size(Y[j])) # ratio of N_ij and the total number of points in i and j
    O[i,j] = O_ij
    O[j,i] = O_ij # symmetry

# 2D blob generation
# Initialize a list of ellipses E
E = []

# For each cluster i in Y:
for i in 1..k:
  # Fit an ellipse E_i to the points of i using eigenvalue decomposition
  # Reference: https://alyssaq.github.io/2015/computing-the-axes-or-orientation-of-a-blob/
  Cov_i = cov(Y[i]) # covariance matrix of cluster i
  L_i, V_i = eig(Cov_i) # eigenvalues and eigenvectors of Cov_i
  A_i = sqrt(L_i[0]) * 2 # major axis length of E_i
  B_i = sqrt(L_i[1]) * 2 # minor axis length of E_i
  Theta_i = atan(V_i[1,0] / V_i[0,0]) # orientation angle of E_i
  
  # Scale E_i by a factor S_i that depends on the size of i
  S_i = log(size(Y[i])) / log(n) # scaling factor based on cluster size and total number of points
  A_i = A_i * S_i # scale major axis length by S_i
  B_i = B_i * S_i # scale minor axis length by S_i
  
  # Add E_i to the list of ellipses E
  E_i = (A_i, B_i, Theta_i) # ellipse parameters
  E.append(E_i)

# 2D blob arrangement
# Initialize a 2D canvas C with width W and height H
W = 10 # arbitrary width
H = 10 # arbitrary height
C = zeros(W, H) # canvas matrix

# Randomly place the 2D blobs on C
# Reference: https://stackoverflow.com/questions/41855695/simulation-how-to-randomly-place-rectangles-without-overlap-python/41856827#41856827

# Define a function to check if a blob overlaps with any existing blob on C
def is_overlapping(blob):
  for b in blobs: # for each existing blob b on C
    if blob.intersects(b): # if blob intersects with b
      return True # return True for overlapping
  return False # return False for no overlapping

# Define a list of blobs blobs
blobs = []

# For each ellipse E_i in E:
for E_i in E:
  # Define a blob object B_i with E_i parameters and a random position on C
  x_i = random(0, W) # random x coordinate on C
  y_i = random(0, H) # random y coordinate on C
  B_i = Blob(x_i, y_i, E_i) # blob object with position and ellipse parameters
  
  # While B_i overlaps with any existing blob on C or is out of bounds:
  while is_overlapping(B_i) or B_i.is_out_of_bounds(W, H):
    # Randomly reposition B_i on C
    x_i = random(0, W)
    y_i = random(0, H)
    B_i.reposition(x_i, y_i)
  
  # Add B_i to the list of blobs blobs
  blobs.append(B_i)

# Define an energy function E that penalizes deviations from the desired proximity and overlap values
# Reference: https://arxiv.org/pdf/2103.02992.pdf
def energy(blobs):
  E = 0 # initialize energy value
  # For each pair of blobs B_i and B_j on C:
  for i in 1..k:
    for j in i+1..k:
      # Compute the current proximity Q_ij as the distance between the centers of B_i and B_j
      Q_ij = distance(B_i.center, B_j.center)
      
      # Compute the current overlap R_ij as the area of intersection between B_i and B_j
      R_ij = B_i.intersection_area(B_j)
      
      # Compute the energy contribution E_ij as a weighted sum of squared errors between P_ij and Q_ij, and O_ij and R_ij
      E_ij = w_p * (P_ij - Q_ij)^2 + w_o * (O_ij - R_ij)^2 # w_p and w_o are weights for proximity and overlap
      
      # Update E by adding E_ij
      E = E + E_ij
  
  # Return E as the energy value
  return E

# Repeat until convergence or maximum iterations:
max_iter = 100 # maximum number of iterations
alpha = 0.01 # learning rate
epsilon = 0.001 # convergence threshold
iter = 0 # iteration counter
E_old = energy(blobs) # initial energy value

while iter < max_iter:
  # For each blob B_i on C:
  for i in 1..k:
    # Compute the gradient G_i of E with respect to the position of B_i
    G_i = gradient(E, B_i.position)
    
    # Update the position of B_i by moving it along the opposite direction of G_i with a learning rate alpha
    B_i.position = B_i.position - alpha * G_i
  
  # Compute the new energy value E_new
  E_new = energy(blobs)
  
  # If the absolute difference between E_new and E_old is smaller than epsilon:
  if abs(E_new - E_old) < epsilon:
    # Break the loop
    break
  
  # Else:
  else:
    # Update E_old with E_new
    E_old = E_new
    
    # Increment iter by 1
    iter = iter + 1

# Plotting
# Plot C with the 2D blobs and their corresponding labels
plot(C, blobs, labels)
```